import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:campus_food_app/domain/entities/menu_item_entity.dart';
import 'package:campus_food_app/domain/repositories/menu_repository.dart';

part 'menu_event.dart';
part 'menu_state.dart';

class MenuBloc extends Bloc<MenuEvent, MenuState> {
  final MenuRepository menuRepository;

  MenuBloc({required this.menuRepository}) : super(MenuInitial()) {
    on<LoadMenuItems>(_onLoadMenuItems);
    on<AddMenuItem>(_onAddMenuItem);
    on<UpdateMenuItem>(_onUpdateMenuItem);
    on<DeleteMenuItem>(_onDeleteMenuItem);
    on<ToggleMenuItemAvailability>(_onToggleMenuItemAvailability);
  }

  Future<void> _onLoadMenuItems(
    LoadMenuItems event,
    Emitter<MenuState> emit,
  ) async {
    emit(MenuLoading());
    try {
      final menuItems = await menuRepository.getMenuItemsByVendor(event.vendorId);
      emit(MenuLoaded(menuItems: menuItems));
    } catch (e) {
      emit(MenuError(message: 'Failed to load menu items: ${e.toString()}'));
    }
  }

  Future<void> _onAddMenuItem(
    AddMenuItem event,
    Emitter<MenuState> emit,
  ) async {
    try {
      final currentState = state;
      List<MenuItemEntity> currentMenuItems = [];

      if (currentState is MenuLoaded) {
        currentMenuItems = currentState.menuItems;
      }

      final newMenuItem = MenuItemEntity(
        menuItemId: '', // Will be generated by repository
        vendorId: event.vendorId,
        name: event.name,
        description: event.description,
        price: event.price,
        imageUrl: event.imageUrl,
        isAvailable: event.isAvailable,
        category: event.category,
        preparationTime: event.preparationTime,
        tags: event.tags,
      );

      final addedMenuItem = await menuRepository.addMenuItem(newMenuItem);
      currentMenuItems.add(addedMenuItem);

      emit(MenuOperationSuccess(
        message: 'Menu item added successfully',
        menuItems: currentMenuItems,
      ));
    } catch (e) {
      emit(MenuError(message: 'Failed to add menu item: ${e.toString()}'));
    }
  }

  Future<void> _onUpdateMenuItem(
    UpdateMenuItem event,
    Emitter<MenuState> emit,
  ) async {
    try {
      final currentState = state;
      if (currentState is MenuLoaded) {
        final updatedMenuItem = MenuItemEntity(
          menuItemId: event.menuItemId,
          vendorId: '', // Will be preserved by repository
          name: event.name,
          description: event.description,
          price: event.price,
          imageUrl: event.imageUrl,
          isAvailable: event.isAvailable,
          category: event.category,
          preparationTime: event.preparationTime,
          tags: event.tags,
        );

        final result = await menuRepository.updateMenuItem(updatedMenuItem);
        final updatedMenuItems = currentState.menuItems.map((item) {
          return item.menuItemId == event.menuItemId ? result : item;
        }).toList();

        emit(MenuOperationSuccess(
          message: 'Menu item updated successfully',
          menuItems: updatedMenuItems,
        ));
      }
    } catch (e) {
      emit(MenuError(message: 'Failed to update menu item: ${e.toString()}'));
    }
  }

  Future<void> _onDeleteMenuItem(
    DeleteMenuItem event,
    Emitter<MenuState> emit,
  ) async {
    try {
      final currentState = state;
      if (currentState is MenuLoaded) {
        final success = await menuRepository.deleteMenuItem(event.menuItemId);
        if (success) {
          final updatedMenuItems = currentState.menuItems
              .where((item) => item.menuItemId != event.menuItemId)
              .toList();

          emit(MenuOperationSuccess(
            message: 'Menu item deleted successfully',
            menuItems: updatedMenuItems,
          ));
        } else {
          emit(const MenuError(message: 'Failed to delete menu item'));
        }
      }
    } catch (e) {
      emit(MenuError(message: 'Failed to delete menu item: ${e.toString()}'));
    }
  }

  Future<void> _onToggleMenuItemAvailability(
    ToggleMenuItemAvailability event,
    Emitter<MenuState> emit,
  ) async {
    try {
      final currentState = state;
      if (currentState is MenuLoaded) {
        final menuItem = currentState.menuItems.firstWhere(
          (item) => item.menuItemId == event.menuItemId,
        );

        final updatedMenuItem = MenuItemEntity(
          menuItemId: menuItem.menuItemId,
          vendorId: menuItem.vendorId,
          name: menuItem.name,
          description: menuItem.description,
          price: menuItem.price,
          imageUrl: menuItem.imageUrl,
          isAvailable: event.isAvailable,
          category: menuItem.category,
          preparationTime: menuItem.preparationTime,
          tags: menuItem.tags,
        );

        final result = await menuRepository.updateMenuItem(updatedMenuItem);
        final updatedMenuItems = currentState.menuItems.map((item) {
          return item.menuItemId == event.menuItemId ? result : item;
        }).toList();

        emit(MenuOperationSuccess(
          message: 'Menu item availability updated',
          menuItems: updatedMenuItems,
        ));
      }
    } catch (e) {
      emit(MenuError(message: 'Failed to update menu item availability: ${e.toString()}'));
    }
  }
}
